---
published: false
---
1 урок
Философия ООП

Реальный мир - сложный
Стандарты по написанию кода

Нужно разрабатывать все системы так, чтобы им могли пользоваться другие люди.
Нужно научится писать качественный код

Мастер важнее, но кирпичи облегчают работу

Ужасный проект с легаси кодом

"Язык программирования - это всего лишь прокладка между браузером и базой данных"
Мы будем изучать мастерство. А то, на каком фреймворке, каком языке, в какой парадигме - это уже не важно.


Какие парадигмы программирования бывают
Парадигма - это область мышления

Императив. 
Придумываем за исполнителя что ему делать.
-----
Императивное программирование. Как сделать! Последовательное выполнение команд по шагам. Для бездумного исполнителя
1 шаг - a = 5;
2 шаг - while (a > b) {}
3 шаг - print a;
-----
Декларативное программирование. Для умного исполнителя

SELECT * FROM user ORDER BY name LIMIT 10; Что нужно сделать!
Говорим человеческим языком что нужно сделать.
Сделай дизайн
Построй дом

ЗагрузиИменаПользователейССортировкой

Эти парадигмы можно сочетать с собой
Но возрастает сложность программы
---
Оператор goto))

---
Структурное программирование

Структуризация кода для повышения уровня абстракции

Принципы:

- Следует отказаться от использования оператора безусловного перехода goto.
- Любая программа строится из трёх базовых управляющих конструкций: последовательность, ветвление, цикл.
- В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом.
- Каждую логически законченную группу инструкций следует оформить как блок (block).
- Все перечисленные конструкции должны иметь один вход и один выход.
- Разработка программы ведётся пошагово, методом «сверху вниз»

function process(a, b) {
    return c;
}

Результат одной функции можно перенаправить в другую функцию

-----

Процедурное программирование (подход) - Разнесение кода по функциям. Есть функции циклы переменные

-----

Функциональное программирование. Есть только функции и константы без присваивания - это основное отличие
от процедурного программирования.

print
    reduce(join,
        map(getFullName,
            filter(isOchn,
                loadStudentsFromFile(file))))



function map($func, $items) {
    if (count($items) > 1) {
        return array_merge(
            [$func(reset($item))],
            map($func, array_slice($items, 1))
        );
    } else {
        return $items;
    }
}

-----


Проблемы

- Лапшекод
- Процедуры облегчили лапшекод
- Неудобство сотен процедур
- Разрозненность данных
- Компоновка по смыслу

Упрощение сложного кода

----------------------
Моделирование реального мира

Выносим в функцию
Удобное разграничение данных

Копирование объектов
a = 5
b = 7
Переменная - это ячейка памяти

b = a // копирование по значению все понятно
Переменная Ссылка Значение
a -> [5]
b -> [5]

b = 11

a -> [5]
b -> [11]

b = &a // копирование по ссылке
функция sort(array)

a -> [5]
b /

b = 12

echo a // 12 так как переменные ссылаются на одну ячейку памяти

$student1 = new Student();

$student1 -> [ @ ] -> {Student#1} // Указатель на объект
b         ->   /

b = $student

// Объект создается всегда один раз, объекты в памяти не копируются

b = &$student

$student1 -> [ @ ] -> {Student#1}
b         ->   /

b = clone a // Копирование объекта

Не использовать передачу по ссылке без необходимости.

// Копирование объектов

class Student {
    public $name;
}

$student1 = new Student();

$student1->name = "test";

$student2 = $student1;
$student2->name = "test2";

$student3 = clone $student1; // так можно скопировать объект
$student3->name = 'clonetest';

echo $student1->name . PHP_EOL;
echo $student2->name . PHP_EOL;
echo $student3->name . PHP_EOL;

Уменее разбивать систему на ящики.

$отделКадров->наймиСотрудника($данныеСотрудника);

==============================

Объектно-ориентированное программирование

На любом интерфейсе должна быть только одна кнопка. Все остальное должно быть скрыто.
Чем меньше проводов между ящиками тем легче с ними работать.

Хорошее ООП
	Разгружает голову
	Привносит модульность
	Повышает совместимость компонентов
	Локализует изменения
	Абстрагируется от реализации. Думаем высокоуровневыми вещами.
	Упрощает код
	Легко тестируется

Недо-ООП
	Привносит сложность
	Сохраняет процедурный подход, не использует плюсы абстракции
	Причиняет неудобство
	Т.е. никакой пользы не привносит
            
                
