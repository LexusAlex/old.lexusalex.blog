--- 
layout: post 
title: Команды git
permalink: git-commands
tags: git github
comments: true
published: false

---

## Список команд

Для удобства разбил команды на группы

- Инициализация и клонирование репозитория
    - [init](#init)
    - [clone](#clone)
- Работа с текущими изменениями
    - [add](#add)
    - [rm](#rm)
    - [mv](#mv)
    - [reset](#reset)
    - [revert](#revert)
    - [clean](#clean)
- Фиксация измений
    - [commit](#commit)
- Ветвление
    - [branch](#branch)
    - [checkout](#checkout)
    - [stash](#stash)
    - [merge](#merge)
    - [tag](#tag)
- История, сравнение файлов
    - [log](#log)
    - [diff](#diff)
    
      

### init

Создает новый репозиторий

~~~bash
# Создание пустого репозитория в текущей директории:
git init # при этом будет создана ветка по умолчанию (master)

# Создание пустого репозитория в указанной директории:
git init test2

# Инициализация репозитория без рабочего каталога (создается только каталог .git):
git init --bare hub.git

# Инициализация нового репозитория с кратким выводом (ошибки и предупреждения)
git init -q test3
~~~

### clone

Клонирует уже созданный репозиторий

~~~bash
# Клонирует локальный репозиторий в указанную папку
git clone hub.git/ test4

# Вариант клонирования репозитория с указанием полного пути
git clone file:///home/alex/git-test/hub.git/ test5

# Клонирует репозитоий по протоколу https
git clone https://example.com/gitproject.git

# Клонирует репозиторий по протоколу ssh
git clone ssh://user@server:project.git

# Клонирует репозиторий по протоколу ssh (git поймет что это ssh)
git clone git@github.com:LexusAlex/php-solutions.git

# Клонирует репозиторий по протоколу git
git clone git://user@somehost:port/~user/repository/project.git

# Склонируем репозиторий без рабочей папки, например если нужно сделать копию оригинального репозитория
git clone --bare hub.git/ hub2.git # что важно bare репозиторий должен имень расширение .git

# Клонирует репозиторий с указанным в истории кол-вом коммитов, в данном случае в истории будет только последний коммит
git clone --depth 1 https://github.com/LexusAlex/php-solutions.git
~~~

### add

Добавляет файлы в индекс для последующего коммита

Состояние файлов:

1. ' ' = unmodified - зафиксирован в репозитории
2.   M = modified - модифицирован
3.   A = added - добавлен
4.   D = deleted - удален
5.   R = renamed - переименован
6.   C = copied - скопирован
7.   U = updated but unmerged - обновлен не не слит

~~~bash
# Добавить в индекс новый, измененный или удаленный фаил
git add file2

# Добавить в индекс несколько файлов и директории
git add file2 file4 /src /test /myproject # git по историческим причинам не видит пустые директории

# Добавить в индекс все файлы в текущей директории и во всех ее поддиреториях
git add .

# Добавить в индекс фаил который есть в файле `.gitignore`, указав флаг `-f`
# После этого работа с файлом ведется обычным образом без указания флага `-f`
git add -f /log/file.log

# Добавить в индекс все файлы кроме созданных
git add -u

# Показать новые/изменённые файлы по очереди с указанием их изменений и вопросом об отслеживании/индексировании

git add -p
~~~

### rm

Удаляет файлы и каталоги и добавляет их в индекс

~~~bash
# Рекурсивное удаление файлов и директорий и добавление файлов в индекс
git rm -r /src # что равносильно rm -rf /src, но без добавления в индекс

# Удалить фаил и добавить его в индекс
git rm text.txt

# Удалить любой ценой фаил, даже если он проиндексирован и там есть изменения
git rm -f text.txt # git по умолчанию действует безопасно, если удаляеться измененный фаил, он не даст это сделать

# Удаление файлов по маске
git rm test*

# Если случайно добавили файл в индекс, его нужно убрать из индекса, но сам фаил не удалиться и останется в рабочей директории
git rm --cached file6
~~~

### mv

Переместить или переименовать фаил или каталог.

~~~bash
# Переименовать файл
git mv README.txt README_test.txt

# Переместить фаил
git mv README.txt folder/
~~~

### reset

Сброс к состоянию любого коммита

~~~bash
# Жесткий сброс, полносью перейти в состояние репозитория на указанном коммите с удалением всех незакоммиченный изменений
git reset --hard 6ar5

# Вернуть обратно что сбросили
git reset ORIG_HEAD

# Просто очистить все незакоммиченные изменения из индекса и из рабочей директории
git reset --hard HEAD

# Мягкий сброс, передвинуть на указанный коммит, при этом остаить все незакоммиченные изменения на один коммит назад
git reset --soft @~

# Сброс индекса, по умолчению последний коммит
git reset HEAD

# Сброс индекса, по указанному пути
git reset files/test.php
~~~

### revert

### clean

Удаление неотслежиевамых файлов и директорий

~~~bash
# Удалим все неотслежиеваемые файлы и директории, включая те которые указаны в `gitignore`
git clean -dxf

~~~

### commit

Фиксирует изменения в репозиторий

~~~bash
#  Добавить проиндексированные изменения в репозиторий (закоммитить) с указанием названия коммита
git commit -m "init message"

# Проиндексировать и добавить изменения в репозиторий (закоммитить) при этом новые файлы не будут закоммичены
git commit -a -m "message"

# Отмена последнего коммита, передвигаем текущую ветку назад, но файлы при этом остаються как есть, по факту создается просто новый коммит
git commit --ammend

# Создать новый коммит под замену предыдущему, с изменением сообщения коммита
git commit --ammend -m "comment"

# Просмотреть в редакторе что будет внесено в коммит, то есть какие файлы были изменены
git commit -v
~~~

### branch

Работа с ветками. Ветка это просто указатель на коммит.

~~~bash
# Список веток, с указанием ветки где мы находимся, например
#   master
# * new   # Ссылка на текущую ветку храниться в файле HEAD, при создании коммита git двигает указатель на последний коммит
git branch

# Список веток, и последний коммит в каждой, расширенная информация
#   master 3dd52c7 adds
# * new    3dd52c7 adds
git branch -v

# Создать новую ветку, то есть ссылки на коммит
git branch new 

# Переместить ветку на указанный коммит
git branch -f master 61d72

# Переместить ветку на коммит на котором указанная ветка
git branch -f master new2

# Удаление ветки если изменения уже влиты, то есть обьединена, в реальности удаляться только ссылка, коммиты остаются
# Это команда работает только если ветка обьединена со вливаемой
git branch -d new2

# Удалить ветку в любом случае, даже если коммиты не были объединены
git branch -D new2

# Если ветка была удалена по ошибке, восстановить ее можно следующим способом, просто создав новую ветку с тем же именем и указывающее на последний коммит
git branch new2 61d67

~~~

### checkout

Переключение веток и восстановление файлов в рабочем каталоге
Эта команда защищает от переключения при незакоммиченных изменениях, она будет ругатся только если изменения
различатся в обоих ветках, иначе он оставлюет фаил как есть, но выводит заметку

~~~bash
# Перейти в указанную ветку
git checkout new

# Создать новую ветку и сразу же перейти в нее, если были какие-то незакомиченные изменения то они перейдут в нее
git checkout -b new2

# Переключение на другую ветку даже при незакомиченных изменениях, при этом git перезапишет все изменения
git checkout -f master

# Привести все изменения в рабочем каталоге, в состояние последнего коммита в нем, то есть на момент HEAD
# При этом изменения в индексе тоже будут сброшены
git checkout -f HEAD

# Переместить ветку с указанным именем на указанный коммит и перейти в неё
git checkout -B master 61d72

# Перейти на указанный коммит
# Состояние "отделённого HEAD" говорит что в HEAD будет находиться не ветка, а ссылка на конкретный коммит
# Если коммитить далее что ваши коммиты будут висеть в воздухе, рекомендуеться создать новую ветку для этого git checkout -b <имя-новой-ветки>
# Такое перемещение используеться для просмотра истории проекта
git checkout a747

# Восстановить фаил на состояние указанного коммита, при этом не будет происходить переключение веток
git checkout a747 index.php
~~~

### stash

Спрятать изменения в индексе. Важно применять эту команду на одной ветке во избежание конфликтов

~~~bash
# Спрятать изменененения в идексе, используеться для переключения между ветками
git stash

# Вернуть изменения назад
git stash pop

~~~

### merge

Слияние веток

~~~bash
# Слить изменения в текущую ветку из ветки fix(нужно перейти на ветку в которую нужно вливать изменения)
# Слиятние перемоткой Fast-forward, в данном случае, указатель просто сдвигается дальше
git merge fix
~~~

### tag

tag это просто ссылка на коммит, просто метка на коммит

~~~bash
# Создает тег. Тег будет всегда указывать на заданный коммит
git tag v2.0 23th5

# Список тегов
git tag

# Удалить теги
git tag -d v1.1 v2.0

# Создать тег с аннотацией
git tag -a -m "Annotation on tag" 1.1 master
~~~

### log

Просмотр истории коммитов

~~~bash
# Длинный вывод лога, по умолчанию выводит коммиты от HEAD
git log

# Вывод в одну строку
git log --oneline 

# Коммиты указанной ветки
git log master

# Показать кол-во последних коммитов
git log -1

# Вывести коммиты в сокращенном формате id коммита(полное или сокращенное) - название
git log --pretty=oneline
git log --pretty=oneline --abbrev-commit
git log --oneline

# Вывод коммитов по формату, ключи указаны в документации
git log --pretty=format:"%h - %an, %ar : %s%d"


~~~

### diff

Сравнение коммитов

~~~bash
# Сравнить коммиты двух веток, разбитым по файлам
# git diff master..branch2 можно и так что тоже самое
git diff master branch2

# Что именно изменилось в branch2 по сравнению с master, то есть сравнение веток
git diff master...branch2

# Сравнить два коммита, разница между файлами двух коммитов
git diff 234fg 5hdf7

# Сравнить изменения в рабочей директории с коммитом который в HEAD
# git diff @
git diff HEAD

# Просмотреть что было изменено и попадет в коммит
git diff --cached

# Изменения в одном файле
git diff index.php

# Изменения текущей директории
git diff .

# Указать путь(директорию) а не ветку для сравнения 
git diff -- master

# Сравнить изменения по словам, что именно было изменено
git diff --word-diff
~~~



git merge hotfix           # влить в ветку, в которой находимся, данные из ветки hotfix
git merge hotfix -m "Горячая правка" # влить в ветку, в которой находимся, данные из ветки hotfix (указано сообщение коммита слияния)
git merge hotfix --log     # влить в ветку, в которой находимся, данные из ветки hotfix, показать редактор описания коммита, добавить в него сообщения вливаемых коммитов
git merge hotfix --no-ff   # влить в ветку, в которой находимся, данные из ветки hotfix, запретить простой сдвиг указателя, изменения из hotfix «останутся» в ней, а в активной ветке появится только коммит слияния

git branch --merged        # показать ветки, уже слитые с активной
git branch --no-merged     # показать ветки, не слитые с активной
git branch -a              # показать все имеющиеся ветки (в т.ч. на удаленных репозиториях)
git branch -m old_branch_name new_branch_name # переименовать локально ветку old_branch_name в new_branch_name
git branch -m new_branch_name # переименовать локально ТЕКУЩУЮ ветку в new_branch_name
git push origin :old_branch_name new_branch_name # применить переименование в удаленном репозитории
git branch --unset-upstream # завершить процесс переименования




 


https://ru.stackoverflow.com/questions/431839/%D0%92-%D1%87%D0%B5%D0%BC-%D1%80%D0%B0%D0%B7%D0%BD%D0%B8%D1%86%D0%B0-%D0%BC%D0%B5%D0%B6%D0%B4%D1%83-git-add-add-a-add-u-%D0%B8-add

git remote add local_proj /opt/git/project.git
Придумать пример с одним локальным центральным репозитрием и двумя которые в него сливают

Важно чтобы каждый коммист делал одну вещь, то есть атомарный коммит
В одном коммите только связанные изменения

Стандартные команды Git используемые в различных ситуациях:


работа с текущими изменениями (смотрите также: git help everyday)
   add        Добавление содержимого файла в индекс
   mv         Перемещение или переименование файла, каталога или символьной ссылки
   reset      Сброс текущего состояния HEAD на указанное состояние
   rm         Удаление файлов из рабочего каталога и индекса

просмотр истории и текущего состояния (смотрите также: git help revisions)
   bisect     Выполнить двоичный поиск изменения, которое вносит ошибку
   grep       Вывод строк, соответствующих шаблону
   log        Вывод истории коммитов
   show       Вывод различных типов объектов
   status     Вывод состояния рабочего каталога

выращивание, отметка и настройка вашей общей истории
   branch     Вывод списка веток,  их создание или удаление
   checkout   Переключение веток или восстановление файлов в рабочем каталоге
   commit     Запись изменений в репозиторий
   diff       Вывод разницы между коммитами, коммитом и рабочим каталогом и т.д.
   merge      Объединение одной или нескольких историй разработки вместе
   rebase     Повторно применить коммиты над верхушкой другой ветки
   tag        Создание метки, вывод списка, удаление или проверка метки, подписанной с помощью GPG

совместная работа (смотрите также: git help workflows)
   fetch      Загрузка объектов и ссылок из другого репозитория
   pull       Извлечение изменений и объединение с другим репозиторием или локальной веткой
   push       Обновление внешних ссылок и связанных объектов

----

