---
layout: post 
title: Объекты в php
permalink: php-objects
tags: php
published: false
---

## Содержание
1. [Проектирование системы](#проектирование-системы)
2. [Основные понятия](#основные-понятия)
3. [Объявление класса](#объявление-класса)
4. [Создание объекта](#создание-объекта)
5. [Свойства класса](#свойства-класса)
6. [Конструктор](#-__construct)
7. [Инкапсуляция](#инкапсуляция)
8. [Деструктор](#-__destruct)
8. [Модификаторы доступа](#модификаторы-доступа)
8. [Наследование](#наследование)

Когда программист начинает работать над сайтом или crm системой, ему необходимо собрать сведенья о предметной области,
определить сущности и связи между ними и составить ER диаграмму. На этом этапе, чем точнее и четче будут определены сущности и связи 
(по сути это называется моделирование объектов реального мира), тем проще в поддержке будет система.
    
Система состоит из объектов. Объекты различными способами взаимодействуют между собой, существуют три типа связи объектов:

- один к одному
- один ко многим
- многие ко многим

Задача программиста выделить значимые части в предметной области и перенести их в код.

### Проектирование системы

При проектировании системы нужно учитывать только необходимую сложность для ее создания.
Нужно уметь видеть и отделять где случайная сложность, а где необходимая.

Следует проектировать систему по уровням, дабы отсечь работу с элементарными единицами.

### Основные понятия

Объект - это некая предметная область, предмет или сущность, например стол, стул, человек, автомобиль, имеющий собственные характеристики.

Состояние объекта определяют его свойства или атрибуты, например стол - деревянный.

Объект может обладать поведением (положением), то есть производить операции над свойствами, поведение объекта выражается в методах объекта.

Класс - это структура (абстракция), декларировав которую можно создать объект класса, или как еще говорят экземпляр. 
Например от класса Автомобиль можно создать объекты Nissan, Opel, Ваз и т.д


### Объявление класса

Чтобы создать объект, сначала нужно определить его класс.

В мире php принято объявлять класс в отдельном файле. 
Название файла и класса следует именовать одинаково, при этом структура
файлов и папок нигде не регламентируется, она зависит от специфики каждого проекта.

Например названия могут быть такими:
1. `HtmlCodeParser`
2. `BaseMessage`
3. `TestController`
4. `BootstrapInterface`
5. `InlineAction`
6. `TestTrait`
7. `ContainerNotRegisteredException`

~~~php
<?php

namespace oop;

class Application
{
    public $object;
}

~~~

Как правило если пакет подгружается через composer, то его классы размещают в подкаталоге `src`, тесты в подкаталоге `tests`

Каждый класс должен быть объявлен в своем пространстве имен, при этом не стоит забывать что пространство имен - это просто строка не к чему не призывающая,
но тем не менее объявлять класс в своем пространстве имен является хорошим тоном

Например:

| N.  | Класс            | Пространство имен              | Полный путь                                                   |
| :--:|:----------------:|:------------------------------:|:-------------------------------------------------------------:|
| 1.  | `DomainException`| `Zend\Http\Header\Exception`   | `zend-http/src/Header/Exception/DomainException.php`          |
| 2.  |`StartSession`    | `Illuminate\Session\Middleware`| `framework/src/Illuminate/Session/Middleware/StartSession.php`|
| 3.  |`BaseYii`         | `yii`                          | `yii2/framework/BaseYii.php`                                  |

Чтобы работала автозагрузка классов нужно добавить пространство имен в секцию `autoload` в фаил `composer.json` и запустить `composer update`.

~~~json
{
"autoload": {
        "psr-4": {
            "oop\\": "src/"
        }
    }
}

~~~
Теперь во входной точке в приложение нужно подключить автозагрузчик

~~~php
<?php

require __DIR__ . './vendor/autoload.php';
~~~

При этом класс будет подключен, только в момент использования, тем самым не нагружая память

Узнать подробнее о composer можно в моей статье [Composer - менеджер зависимостей php](http://lexusalex.ru/php-composer)

### Создание объекта

Создадим объект от нашего класса `Application`, для этого используется ключевое слово `new`.
В данном случае класс определен в своем пространстве имен `oop`

~~~php
<?php
use oop\Application; // импорт класса

$object1 = new \oop\Application(); // () - контруктор (будет рассмотрен позже)
$object2 = new Application; // если конcтруктор не определен, то () можно опустить
$nameObject = 'oop\Application'; // или \oop\Application::class
$object3 = new $nameObject(); // возможно создать объект динамически, определив имя класса в строку
~~~

Важный момент при присвоениии объекта в переменную будет записан указатель на него.

Например во всех четырех случаях будет скопирована ссылка на обьект `$object1`
~~~php
<?php
use oop\Application;

$object1  = new Application();
$copyObject1 = $object1;
$copyObject2 = $copyObject1;
$copyObject3 = $copyObject2;
var_dump($object1, $copyObject1, $copyObject2, $copyObject3);

/* 
object(oop\Application)[3]
  public 'object' => null
*/
~~~

### Свойства класса

Свойства в общем понимании - это характеристики объекта. Они хоть и описываются в классе, но принадлежат объекту

~~~php
<?php

namespace oop;

class Student
{
    public $age; // null
    public $course = 0;
    public $desc = <<<'NOW'
    Описание студента
NOW;

}

~~~

> По умолчанию значение свойства null

Свойства могут содержать любые постоянные значения (нельзя присваивать другие переменные, вызывать функции), 
в которые при создании объекта можно писать, и так же читать их.

~~~php
<?php
use oop\Student;

$student1 = new Student();
$student1->age = 24;
$student1->course = 1;
$student1->desc = "Студент Вася";

$student2 = new Student();
$student2->age = 26;
$student2->course = 3;
$student2->desc = "Студент Петя";
~~~

В примере выше мы создали два объекта класса `Student`. Произведем некоторые манипуляции со свойствами объекта

~~~php
<?php

unset($student2->desc); // удалим свойство из объекта, теперь при обращении к этому свойству будет Notice: Undefined property: oop\Student::$desc
$student2->test = 'Добавление свойства которого нет в классе'; // динамически добавим полноценное свойство в объект

$course = "course";
$student2->$course = 4; // возможно задать имя свойства в переменную и обращаться к ней таким образом
$student2->{"$course"} = 4; // или так
~~~

### Конструктор __construct()

Конструктор - это специальная функция которая автоматически вызывается при создании объекта, которую невозможно вызвать напрямую.

~~~php
 __construct ([ mixed $args [, $... ]] ) : void
~~~

> Методы которые начинаются с __ именуются магическими и должны быть объявлены как public

В конструктор передаются параметры которыми нужно инициализировать объект, при этом конструктор не должен ничего возвращать

~~~php
<?php

declare(strict_types=1);

namespace oop;

class Student
{
    private $age;
    private $course = 0;
    private $desc = <<<'NOW'
    Описание
NOW;

    public function __construct(int $age, int $course, string $desc)
    {
        $this->age = $age;
        $this->course = $course;
        $this->desc = $desc;
    }
}
~~~

Основная задача конструктора заполнить объект переданными значениями это могут быть инициализационные данные или
настройки для работы, но по сути конструктор это обычная функция.

> $this - это ссылка на создаваемый объект, она попадает в конструтор как нулевой параметр

В итоге код можно сократить и переписать таким образом

~~~php
<?php

use oop\Student;

$student1 = new Student(24, 1, "Студент Вася");
$student2 = new Student(26, 3, "Студент Петя");
$student3 = new Student(22, 1, "Студент Вова");
~~~

Бывает необходимо закрыть свойство от прямого доступа из глобальной области видимости, для этого используются 
модификаторы доступа, их мы рассмотрим ниже. В данном примере все свойства класса мы сделали приватными, доступ к
которым возможен только в контексте класса.

### Инкапсуляция

Для того, чтобы получить доступ к чтению и изменению свойств, нужно добавить методы для чтения `геттер (getters)` и
для записи `сеттер (setters)` которые будут обращаться к этим свойствам.

~~~php
<?php

declare(strict_types=1);

namespace oop;

class Student
{
    private $age; // null
    private $course = 0;
    private $desc = <<<'NOW'
    Описание
NOW;

    public function __construct(int $age, int $course, string $desc)
    {
        $this->age = $age;
        $this->course = $course;
        $this->desc = $desc;
    }

    /**
     * @return int
     */
    public function getAge(): int
    {
        return $this->age;
    }

    /**
     * @param int $age
     */
    public function setAge(int $age): void
    {
        $this->age = $age;
    }

    /**
     * @return int
     */
    public function getCourse(): int
    {
        return $this->course;
    }

    /**
     * @param int $course
     */
    public function setCourse(int $course): void
    {
        $this->course = $course;
    }

    /**
     * @return string
     */
    public function getDesc(): string
    {
        return $this->desc;
    }

    /**
     * @param string $desc
     */
    public function setDesc(string $desc): void
    {
        $this->desc = $desc;
    }
    
}
~~~

Такой подход дает следующие преимущества:

1. Защита от прямого изменения свойств
2. Дополнительная обработка, расчеты при доступе или изменению свойства
3. Возможность писать код с наименьшим количеством побочных эффектов, определив их один раз в конструкторе

### Деструктор __destruct()

Следующий магический метод называется деструктор.

~~~php
 __destruct ( void ) : void
~~~

Деструктор вызывается автоматически когда будет завершена работа скрипта или будут удалены все ссылки на объект.

На практике необходимость в использовании деструкторов бывает крайне редко

~~~php
<?php

class Student
{
   public function __destruct()
   {
       echo 'обьект удален из памяти';
   } 
}

~~~

### Модификаторы доступа

Для того, чтобы ограничить доступ к свойствам, методам и константам класса используются модификаторы доступа:

- public - доступ разрешен отовсюду
- protected - доступ внутри класса, и классам наследникам
- private - доступ разрешен только внутри класса

### Наследование

Наследование - это возможность классов наследовать функциональность друг друга.





### Взаимодествие классов


Понятия объект, класс, шаблон проектирования

Используеются для решения

Каждый паттерн описывает некую повторяющуюся проблему и ключ к ее разгадке, причем таким образом, что этим ключом можно пользоваться при решении самых разнообразных задач

Цель применения

Для решения типовых задач

Реаизация и является решением задачи

Описывает решаение целого класса задач

Инкапсуляция - состояние обьекта может быть изменено только самим классом, и только там закрывать изменение из вне
Вннутренее состояние системы это дело самой системы
это принцип, согласно которому любой класс и в более широком смысле – любая часть системы, должны рассматриваться как чёрный ящик — пользователь класса или подсистемы должен видеть и использовать только интерфейс (т. е. список декларируемых свойств и методов) и не вникать во внутреннюю реализацию. 
позволяет (теоретически) минимизировать число связей между классами и подсистемами и, соответственно, упростить независимую реализацию и модификацию классов и подсистем.

Наследование -  

Полиморфизм - классы потомки как будто это класс предок

Выявление сущеностей для проекта

http://php.net/manual/ru/language.oop5.basic.php
http://svyatoslav.biz/misc/psr_translation/#_PSR-2
https://ru.hexlet.io/courses/php-introduction-to-oop/lessons/classes/theory_unit


