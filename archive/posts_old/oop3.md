---
published: false
---
Важно понимать как объекты взаимодействуют друг с другом.

Наследуемся грамотно, избегая хаоса
Мышление ООПэшного программиста
Почему неООПэшника сразу видно
Чем же абстрактный класс отличается от интерфейса

Наследование
Полиморфизм
Инкапсуляция

Использование принципов по-полной

----

Все нужно делать так, чтобы было удобнее.
Начинаем думать категориями.

Наследование. 

Это фишка поддерживаемой самым php.
Наследование классов extends
Расширения классов что было в первом классе наследуется во втором
так же можно спокойно переопределить любой метод.
Одним типом расширить другой.
Наследование не работает обратно, оно работает сверху вниз.

class Sub extends Base
Наследовать можно как угодно. 
Ограничение есть ли в одном случае нельзя множественно наследоваться
Нельзя зациклить наследование.
Можно наследоваться только один раз от одного класса.
Можно переопределить конструктор, в дочернем классе нужно вызвать родительсвий
конструктор

parent::__construct($name, $email);
parent::first()

self текущий класс
parent родительский класс
методы можно вызывать в пределах одного класса
В дочернем классе можно переопределить любой метод
приватные методы не прокидываются автоматически в дочерней класс, даже
наследник не имеет к нему доступ.
Метод должен быть protected.
К вспомогательным метододам нужно закрывать доступ

Программиста интересует в первую очерередь что можно вызвать снаружи
public
protected
private

из php4 пришла привычка определять приватные методы с _

static::second() Позднее статическое связывание
Может понадобаится сделать класс от которого можно только наследоваться
его нужно объявить абстрактным abstract
или можно запретить его наследовать объявить как final 

От абстрактного класса можно только наследоваться

Метод можно сделать абстрактным без тела тем самым сделав его обязательным к переопределению в классах
наследниках

Так же метод может быть финальным его нельзя переопределить.
Наследование нужно для разделения кода по отвественностям
Наследование работает, для того чтобы определить, что один тип является подтипом другого.

          class Animal
        /       |      \
class Birth class Dog  class Cat

class A {}
   3 общих метода
class B extends A {}
    2 своих
class C extends A {}
    9 своих
    
Наследуйте только те вещи которые находятся в родстве    
Делегирование классов внутри.     
    

Трейты

Реализует паттерн примесь.
Это не класс - это просто куски кода


trait filtertrait {
 
}

class test {
use filtertrait
}

Не воспринимайте трейт как класс - это просто методы и свойства, куски кода которые можно использовать
Трейт это костыль.
Разные классы не могут требовать один и тот же код.

Трейты - это примочка к классу
 
 
-----

Если есть повторяющиеся методы то можно сделать базовый класс

Интерфейс должен реализовать класс
В нем нельзя писать код, в нем можно определить методы и константы

Для каждого из компонентов можно сделать свои интерфейсы
их можно реализовывать сколько угодно.

Вспомогательная конструктция - она намного легче класса.

Интерфейсы можно также наследовать друг от друга

intarface Test extends Colorized {

}

Используем интерфейсы только лишь для типизации.

Интерфейс представляет из себя только тип.

С интерфейсом можно делать все тоже самое что и с классом.
Интерфейс это просто набор методов.
Наследование интерфейсов и классов работает одинаково.

Можно написать компоненты которые будут поддерживать бесконечное количество реализаций


Переопределить от базового класса
 
3 часа 54 мин

